---
title: Mistrzostwo i doskonałość
pubDate: 20 Aug 2022
language: pl
---
Często powtarzaną mantrą w zwinnym wytwarzaniu oprogramowania jest stwierdzenie, że „zrobione jest lepsze niż doskonałe". W kontekście biznesowym oprogramowania powierzchowna interpretacja tego aforyzmu jest oczywista i oczywista sama w sobie, ponieważ funkcjonalność, która jest zrobiona, ale słabo działająca, może wciąż przynosić wartość biznesową, w przeciwieństwie do funkcjonalności, która jest nadal w fazie rozwoju i nie znajduje się w produkcji. Jednak chociaż takie jest jego zamierzone znaczenie, nie daje ono żadnej użytecznej wskazówki dotyczącej tego, jak należy podchodzić do wytwarzania, i jako takie ma tendencję do sugerowania, że dozwolone jest pisanie brzydkiego kodu, który działa, i nigdy nie uczenie się niczego o tym, dlaczego jest brzydki lub jak można go poprawić.

Rzeczywiście widziałem, jak ten cytat jest wykorzystywany do usprawiedliwiania wielu nieodpowiedzialnych zachowań, gdy jego duch nie jest właściwie wyjaśniony. Właściwości „zrobione" i „doskonałe" dotyczą obiektu. Doskonałość obiektów nie jest możliwa w żadnym rozsądnym znaczeniu, a dążenie do doskonałości pojedynczego obiektu jest skazane na napotkanie malejących zwrotów w pewnym momencie i dlatego jest nieproduktywne.

Co oznacza doskonały kod? Moglibyśmy powiedzieć, że przede wszystkim spełnia cel biznesowy, jest zgodny z zasadami <abbr>SOLID</abbr>, jest napisany czytelnie — to znaczy łatwo jest wywnioskować jego cel przez każdego, kto będzie go czytał w przyszłości, umożliwia innym budowanie nowych funkcjonalności na jego podstawie w przyszłości, gdy będą potrzebne, jest dobrze przetestowany, typowany i udokumentowany.

Istnieje wiele właściwości doskonałego kodu i gdy zostaną przedstawione z fragmentem, który wydaje się je wszystkie spełniać, nie byłoby trudne znalezienie kolejnych sposobów na jego „ulepszenie". Ten fakt wydaje się podkreślać przesłankę, że bezsensowne jest gonić za doskonałym kodem, ponieważ doskonałość obiektu jest nieosiągalna. W pewnym momencie fragment kodu, nad którym pracujemy, będzie wystarczająco dobry, a wzrost jakości wynikający z dodania nowego testu jednostkowego lub kolejnego refaktoringu będzie niewielki lub, być może, negatywny. Kolejna warstwa abstrakcji może sprawić, że kod będzie bardziej elegancki lub rozszerzalny, ale wpłynie to na czytelność, szczególnie w przypadku, gdy może nie wymagać już więcej rozszerzeń. Podobnie, dodawanie większej liczby testów sprawia, że kod jest mniej modyfikowalny, ponieważ każda zmiana w kodzie produkcyjnym powinna również wymagać zmiany w testach.

Problem z „zrobione jest lepsze niż doskonałe" polega na błędnym zrozumieniu tego jako „zrobione jest wystarczające". Zrobiony fragment kodu to być może tylko taki, który spełnia cel biznesowy. Ale żaden fragment kodu nie jest wyspą i nadejdzie czas, kiedy będzie musiał się zmienić i wpłynąć na inne elementy systemu, i dlatego rozsądne jest oczekiwanie pewnego poziomu jakości od kodu, który jest zatwierdzany do repozytorium. Więc zrobione może być lepsze niż doskonałe, ale dobrze zrobione jest lepsze niż tylko zrobione.

Dodatkowo, „zrobione jest lepsze niż doskonałe" nie zwalnia z rozważenia, jak kod mógłby rzeczywiście być bardziej doskonały, być może z przywilejem spojrzenia wstecz uzyskanego po ostatnim commicie. Może nie być konieczne działanie na tym i dodawanie ulepszeń do kodu, który jest „zrobiony", do bazy kodu, ale zawsze jest przydatne myślenie o tym, jak mógłby zostać ulepszony. Po pierwsze, ponieważ może nadejść czas w przyszłości, kiedy będzie musiał zostać ulepszony, a po drugie, aby rozwinąć doświadczenie, które pozwoli na wyprowadzenie sposobów na zrobienie tego poprawnie za pierwszym razem w przyszłości.

Zamiast doskonałości kodu, należy dążyć do mistrzostwa jako programista. Jednym z wyróżników takiego mistrzostwa jest intuicja co do poprawnych rozwiązań, zanim zostaną one w ogóle wypróbowane. Wiedza o modelowaniu, abstrakcjach i wzorcach projektowych jest tu często nieoceniona, ponieważ czasami godzina dobrego projektowania może zaoszczędzić tydzień kodowania. Ponadto, przy rozwijaniu funkcjonalności lub projektów z napiętymi terminami, będzie trzeba podejmować decyzje w oparciu o niepełne informacje, decyzje, które są mało prawdopodobne, aby były poprawne bez pewnej dozy intuicji i doświadczenia.

Staranna i przemyślana analiza już opracowanych rozwiązań oraz chęć szukania ulepszeń to kolejna skłonność, która odróżnia nowicjuszy od mistrzów. Nowicjusz może skończyć rozwijać funkcjonalność, zatwierdzić ją do repozytorium, uznać swoją pracę za ukończoną i znaleźć coś innego do zrobienia. Mistrz rozumie, że najprawdopodobniej zostały poczynione pewne skróty w celu dostarczenia funkcjonalności na czas i dokumentuje możliwe przyszłe ulepszenia lub kierunki rozwoju planowanych rozszerzeń. Dążenie do mistrzostwa oznacza również szukanie tego, przy jednoczesnym zrozumieniu, że te ulepszenia mogą nie być konieczne w bieżącym kontekście biznesowym.

Istnieje również różnica między mistrzostwem a stażem pracy. Staż pracy to znacznie szersze pojęcie, odnoszące się bardziej do przedsięwzięć budowania zespołu, gdzie odpowiada się za zapewnienie, że umiejętności całego zespołu są wykorzystywane jak najlepiej. W przeciwieństwie do tego, mistrzostwo jest czysto indywidualnym dążeniem, które istnieje tylko między programistą a jego narzędziami.
